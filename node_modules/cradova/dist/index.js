// lib/scripts/Screen.ts
var Screen = class {
  constructor(cradova_screen_initials) {
    this.packed = false;
    this.secondaryChildren = [];
    this.persist = true;
    this.rendered = false;
    this.effects = [];
    const { template, name, callBack, transition, persist } = cradova_screen_initials;
    if (typeof template !== "function") {
      throw new Error(
        " \u2718  Cradova err:   only functions that returns a cradova element is valid as screen"
      );
    }
    this.html = template.bind(this);
    this.name = name;
    this.template = document.createElement("div");
    this.template.id = "cradova-screen-set";
    this.callBack = callBack;
    this.transition = transition;
    if (typeof persist !== "undefined") {
      this.persist = true;
    }
    if (persist === false) {
      this.persist = false;
    }
  }
  effect(fn) {
    if (!this.rendered) {
      this.effects.push(fn);
    }
  }
  async effector() {
    if (!this.rendered) {
      this.rendered = true;
      for (let fnIdex = 0; fnIdex < this.effects.length; fnIdex++) {
        const fn = this.effects[fnIdex];
        const data = await fn();
        if (data) {
          await this.Activate(data, true);
        }
      }
    }
  }
  async package(data) {
    if (typeof this.html === "function") {
      let fuc = await this.html(data);
      if (typeof fuc === "function") {
        fuc = fuc(data);
        if (!(fuc instanceof HTMLElement)) {
          throw new Error(
            " \u2718  Cradova err:   only parent with descendants is valid"
          );
        } else {
          this.template.replaceChildren(fuc);
        }
      }
    }
    if (!this.template.firstChild) {
      throw new Error(
        " \u2718  Cradova err:  no screen is rendered, may have been past wrongly, try ()=> screen; in cradova Router.route(name, screen)"
      );
    }
    this.template.append(...this.secondaryChildren);
  }
  onActivate(cb) {
    this.callBack = cb;
  }
  addChild(...addOns) {
    for (let i = 0; i < addOns.length; i++) {
      if (addOns[i] && addOns[i] instanceof HTMLElement) {
        this.secondaryChildren.push(addOns[i]);
      }
      if (addOns[i] && typeof addOns[i] === "function") {
        this.secondaryChildren.push(addOns[i]());
      }
    }
  }
  deActivate() {
    this.template.parentElement?.removeChild(this.template);
  }
  async Activate(data, force) {
    if (!this.persist) {
      await this.package(data);
      this.packed = true;
    } else {
      if (!this.packed) {
        await this.package(data);
        this.packed = true;
      }
    }
    if (force) {
      await this.package(data);
      this.packed = true;
    }
    document.title = this.name;
    document.querySelector("[data-cra-id=cradova-app-wrapper]").append(this.template);
    if (!this.persist) {
      this.packed = false;
    }
    await this.effector();
    if (this.template.firstChild.afterMount) {
      this.template.firstChild.afterMount();
    }
    if (this.transition) {
      this.template?.classList.add("CRADOVA-UI-" + this.transition);
    }
    if (this.callBack) {
      await this.callBack(data);
    }
    window.scrollTo(0, 0);
  }
};
Screen.SCALE_IN = "SCALE-IN";
Screen.SCALE_OUT = "SCALE-OUT";
Screen.CIRCLE_IN = "CIRCLE-IN";
Screen.CIRCLE_OUT = "CIRCLE-OUT";
Screen.FADE_OUT = "FADE-OUT";
Screen.FADE_IN = "FADE-IN";
Screen.SLIDE_UP = "SLIDE-UP";
Screen.SLIDE_DOWN = "SLIDE-DOWN";
Screen.SLIDE_LEFT = "SLIDE-LEFT";
Screen.SLIDE_RIGHT = "SLIDE-RIGHT";

// lib/scripts/Scaffold.ts
var Scaffold = class {
  constructor() {
    this.history = [];
    this.Scaffolds = {};
  }
  async push(label, data, force) {
    if (this.Scaffolds[label]) {
      if (this.history.length) {
        this.Scaffolds[this.history[this.history.length - 1]].deActivate();
      }
      if (data) {
        await this.Scaffolds[label].Activate(data, force);
      } else {
        await this.Scaffolds[label].Activate();
      }
      this.history.push(label);
    } else {
      throw new Error(
        "\u2718  Cradova err : no  Scaffold labeled  " + label + " provided!"
      );
    }
  }
  async pop(data, force) {
    if (!this.history.length || this.history.length === 1) {
      return;
    }
    this.Scaffolds[this.history[this.history.length - 1]].deActivate();
    this.history.pop();
    await this.Scaffolds[this.history[this.history.length - 1]].Activate(
      data,
      force
    );
  }
  async addScaffolds(scaffolds) {
    let i = 0, lab = "";
    for (const label in scaffolds) {
      const scaffold = scaffolds[label];
      if (scaffold.template) {
        this.Scaffolds[label] = scaffold;
      } else {
        console.error("\u2718  Cradova got", scaffold);
        throw new Error(
          "\u2718  Cradova err : Scaffold of label '" + label + "' didn't receive a invalid Scaffold component type"
        );
      }
      if (i === 0) {
        lab = label;
      }
      i++;
    }
    if (lab) {
      await this.push(lab);
      return;
    }
    throw new Error("\u2718  Cradova err : no  Scaffold given!");
  }
};

// lib/scripts/Router.ts
var Router = {};
Router["lastNavigatedRouteController"] = null;
Router["nextRouteController"] = null;
Router["lastNavigatedRoute"] = null;
Router["pageShow"] = null;
Router["pageHide"] = null;
Router["params"] = {};
Router["routes"] = {};
var checker = (url) => {
  if (Router.routes[url]) {
    return [Router.routes[url], null];
  }
  for (const path in Router.routes) {
    if (!path.includes(":")) {
      continue;
    }
    const urlFixtures = url.split("/");
    const pathFixtures = path.split("/");
    if (pathFixtures.length === urlFixtures.length) {
      urlFixtures.shift();
      pathFixtures.shift();
      let isIt = true;
      const routesParams = {};
      for (let i = 0; i < pathFixtures.length; i++) {
        if (!pathFixtures[i].includes(":") && path.includes(urlFixtures[i] + "/") && pathFixtures.indexOf(urlFixtures[i]) === pathFixtures.lastIndexOf(urlFixtures[i])) {
          if (!isIt)
            isIt = true;
        } else {
          if (pathFixtures[i].includes(":")) {
            continue;
          }
          isIt = false;
        }
        if (!(pathFixtures.indexOf(urlFixtures[i]) === pathFixtures.lastIndexOf(urlFixtures[i]))) {
          throw new Error(
            " \u2718  Cradova err:  cradova router doesn't allow paths with multiple names"
          );
        }
      }
      if (isIt) {
        for (let i = 0; i < pathFixtures.length; i++) {
          if (pathFixtures[i].includes(":")) {
            routesParams[pathFixtures[i].split(":")[1]] = urlFixtures[i];
          }
        }
        return [Router.routes[path], routesParams];
      }
    }
  }
  return [];
};
Router.route = function(path = "/", screen) {
  if (!screen.Activate && screen.name) {
    console.error(" \u2718  Cradova err:  not a valid screen  " + screen);
    throw new Error(" \u2718  Cradova err:  Not a valid cradova screen component");
  }
  Router.routes[path] = {
    controller: (params, force) => screen.Activate(params, force),
    packager: async (params) => await screen.package(params),
    deactivate: () => {
      screen.deActivate();
    }
  };
};
Router.navigate = function(href, data = null, force = false) {
  if (typeof data === "boolean") {
    force = true;
    data = null;
  }
  if (typeof href !== "string") {
    throw new TypeError(
      " \u2718  Cradova err:  href must be a defined path but got " + href + " instead"
    );
  }
  let route = null, params, link = null;
  if (href.includes(".")) {
    window.location.href = href;
  } else {
    if (href === window.location.pathname) {
      return;
    }
    [route, params] = checker(href);
    if (route) {
      Router["nextRouteController"] = route;
      Router.params.params = params || null;
      Router.params.data = data || null;
      link = href;
      Router["pageHide"] && Router["pageHide"](href + " :navigated");
      window.history.pushState({}, "", link);
      setTimeout(async () => {
        await Router.router(null, force);
      }, 0);
    }
  }
};
Router.router = async function(e, force = false) {
  let Alink, url, route, params;
  if (e && e.target.tagName) {
    Alink = e.target;
    if (Alink && Alink.href.includes("#")) {
      return;
    }
    if (Alink && Alink.href.includes("javascript")) {
      return;
    }
    e.preventDefault();
    if (Alink) {
      url = new URL(Alink.href).pathname;
    }
  }
  if (!url) {
    url = window.location.pathname;
  }
  if (url === Router["lastNavigatedRoute"]) {
    return;
  }
  if (Router["nextRouteController"]) {
    route = Router["nextRouteController"];
    Router["nextRouteController"] = null;
    params = Router.params.params;
  } else {
    [route, params] = checker(url);
  }
  if (route) {
    Router.params.event = e;
    Router.params.params = params || null;
    Router.params.data = Router.params.data || null;
    Router["lastNavigatedRouteController"] && Router["lastNavigatedRouteController"].deactivate();
    await route.controller(Router.params, force);
    Router["pageShow"] && Router["pageShow"](url);
    Router["lastNavigatedRoute"] = url;
    Router["lastNavigatedRouteController"] = route;
    Array.from(window.document.querySelectorAll("a")).forEach((a) => {
      a.addEventListener("click", (e2) => {
        e2.preventDefault();
        Router.navigate(a.pathname);
      });
    });
  } else {
    if (Router.routes["/404"]) {
      Router.routes["/404"].controller(Router.params);
    } else {
      console.error(
        " \u2718  Cradova err: route '" + url + "' does not exist and no /404 route given!"
      );
    }
  }
};
Router["onPageShow"] = function(callback) {
  if (typeof callback === "function") {
    Router["pageShow"] = callback;
  } else {
    throw new Error(
      " \u2718  Cradova err:  callback for pageShow event is not a function"
    );
  }
};
Router["onPageHide"] = function(callback) {
  if (typeof callback === "function") {
    Router["pageHide"] = callback;
  } else {
    throw new Error(
      " \u2718  Cradova err:  callback for pageHide event is not a function"
    );
  }
};
Router.packageScreen = async function(path, data) {
  if (!Router.routes[path]) {
    console.error(" \u2718  Cradova err:  no screen with path " + path);
    throw new Error(" \u2718  Cradova err:  cradova err: Not a defined screen path");
  }
  await Router.routes[path].packager(data);
};
window.addEventListener("pageshow", Router.router);
window.addEventListener("popstate", (e) => {
  e.preventDefault();
  Router.router(e);
});

// lib/scripts/fns.ts
var err = function(errors, err2, type) {
  for (let er = 0; er < errors.length; er++) {
    console.error(" \u2718  Cradova err:  ", errors[er]);
  }
  if (!type) {
    throw new Error(" \u2718  Cradova err:  " + err2);
  } else {
    throw new TypeError(" \u2718  Cradova err:  " + err2);
  }
};
var controls = function() {
  const svg = `<svg width="20" height="20" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
 <path d="M4.49975 5.625C4.3402 5.6242 4.18282 5.58788 4.03904 5.5187C3.89526 5.44951 3.76869 5.34919 3.6685 5.225L1.03725 2.0375C0.8835 1.84561 0.786745 1.61438 0.758014 1.37017C0.729283 1.12596 0.769733 0.878589 0.874753 0.65625C0.959928 0.463017 1.09892 0.298383 1.27514 0.182014C1.45136 0.0656449 1.65734 0.00245816 1.8685 0H7.131C7.34216 0.00245816 7.54815 0.0656449 7.72437 0.182014C7.90058 0.298383 8.03958 0.463017 8.12475 0.65625C8.22977 0.878589 8.27023 1.12596 8.24149 1.37017C8.21276 1.61438 8.11601 1.84561 7.96226 2.0375L5.331 5.225C5.23082 5.34919 5.10424 5.44951 4.96047 5.5187C4.81669 5.58788 4.65931 5.6242 4.49975 5.625Z" fill="#2c3e50"/>
</svg>
`;
  const icon = (styles) => lib_default("div", { ...styles, innerHTML: svg });
  const constr = lib_default(
    "div",
    {
      display: "flex",
      position: "fixed",
      alignContent: "center",
      justifyContent: "space-around",
      flexDirection: "row",
      width: "80px",
      top: "4px",
      right: "4px",
      backgroundColor: "#fff",
      transform: "rotate(0deg)",
      border: "aqua 2px solid",
      borderRadius: "6px"
    },
    icon({
      transform: "rotate(90deg)",
      onclick() {
        window.history.back();
      }
    }),
    icon({
      transform: "rotate(270deg)",
      onclick() {
        window.history.forward();
      }
    })
  );
  const cont = constr();
  if (cont) {
    document.body.append(cont);
  }
};
function uuid() {
  let t = Date.now ? +Date.now() : +new Date();
  return "cradova-id-xxxxxxxxxx".replace(/[x]/g, function(e) {
    const r = (t + 16 * Math.random()) % 16 | 0;
    return ("x" === e ? r : 7 & r | 8).toString(16);
  });
}
function PromptBeforeLeave(callback) {
  window.history.pushState(
    "forward",
    "",
    window.location.pathname + "#forward"
  );
  window.addEventListener("popstate", (e) => {
    if (callback) {
      callback(e);
    } else {
      alert("Are you sure, you want to go back?");
    }
  });
}
function media(value, ...properties) {
  const styS = "@media only screen and (" + value + `) {
`, styE = `}
`;
  let style = "  ", aniSty = " ";
  const proplen = properties.length;
  let totalAnimation, Animation = "  ";
  const animationStep = (num) => {
    style = "  ";
    for (const [k, v] of Object.entries(properties[num][1])) {
      style += "" + k + ": " + v + `;
`;
    }
    aniSty += "" + properties[num][0] + `{
` + style + `}
`;
    return aniSty;
  };
  for (let i = 0; i < proplen; i++) {
    Animation += animationStep(i);
  }
  let aniStyleTag = document.querySelector("style");
  if (aniStyleTag === null) {
    aniStyleTag = document.createElement("style");
  }
  aniStyleTag.media = "screen";
  totalAnimation = aniStyleTag.innerHTML + `

`;
  totalAnimation += styS + Animation + styE;
  aniStyleTag.innerHTML = totalAnimation;
  document.head.append(aniStyleTag);
}
function css(identifier, properties) {
  const styS = "" + identifier + `{
`;
  const styE = `}
`;
  let style = "", totalStyle = "";
  for (const [k, v] of Object.entries(properties)) {
    style += "" + k + ": " + v + `;
`;
  }
  let styleTag = document.querySelector("style");
  if (styleTag !== null) {
    totalStyle += styleTag.innerHTML;
    totalStyle += styS + style + styE;
    styleTag.innerHTML = totalStyle;
    return;
  }
  styleTag = document.createElement("style");
  totalStyle += styleTag.innerHTML + `

`;
  totalStyle += styS + style + styE;
  styleTag.innerHTML = totalStyle;
  document.head.append(styleTag);
}
function animate(identifier, ...properties) {
  const styS = "@keyframes " + identifier + ` {
`, styE = `}
`, proplen = properties.length;
  let style = " ", aniSty = " ", Animation = "  ", totalAnimation = null;
  const animationStep = (num) => {
    style = "  ";
    for (const [k, v] of Object.entries(properties[num][1])) {
      style += "" + k + ": " + v + `;
`;
    }
    aniSty += "" + properties[num][0] + `{
` + style + `}
`;
    return aniSty;
  };
  for (let i = 0; i < proplen; i++) {
    Animation += animationStep(i);
  }
  let aniStyleTag = document.querySelector("style");
  if (aniStyleTag === null) {
    aniStyleTag = document.createElement("style");
  }
  aniStyleTag.media = "screen";
  totalAnimation = aniStyleTag.innerHTML + `

`;
  totalAnimation += styS + Animation + styE;
  aniStyleTag.innerHTML = totalAnimation;
  document.head.append(aniStyleTag);
}
function assert(condition, ...callback) {
  if (condition) {
    return callback;
  }
  return "";
}
function assertOr(condition, ifTrue, ifFalse) {
  if (condition) {
    return ifTrue;
  }
  return ifFalse;
}
function RefElement(element_initials = "div", props = {}, ...other) {
  const stateID = uuid();
  if (Object.prototype.toString.call(props) !== "[object Object]") {
    other = props;
    props = { stateID };
  } else {
    props["stateID"] = stateID;
  }
  const element = lib_default(element_initials, props, other);
  return {
    render(data) {
      return element(data);
    },
    r(data) {
      return element(data);
    },
    instance() {
      return dispatch(stateID, {
        cradovaDispatchTrackBreak: true
      });
    },
    i() {
      return dispatch(stateID, {
        cradovaDispatchTrackBreak: true
      });
    },
    updateState(state) {
      dispatch(stateID, state);
    },
    u(state) {
      dispatch(stateID, state);
    }
  };
}
var ls = {};
ls.store = (name, value) => {
  localStorage.setItem(name, JSON.stringify(value));
};
ls.retrieve = (name) => {
  return localStorage.getItem(name);
};
ls.remove = (name) => {
  localStorage.removeItem(name);
};
ls.getKey = (index) => {
  return window.localStorage.key(index);
};
ls.clear = () => {
  localStorage.clear();
};
function fullScreen(e) {
  return {
    set() {
      e.requestFullscreen().catch((err2) => {
        throw err2;
      });
    },
    exist() {
      document.exitFullscreen();
    }
  };
}
var RefList = class {
  constructor(component) {
    this.stateID = uuid();
    this.parentElement = null;
    this.datas = [];
    this.component = component.bind(this);
  }
  stale(datas) {
    this.datas = datas;
  }
  r(d) {
    return this.render(d);
  }
  u(d) {
    return this.updateState(d);
  }
  render(datas) {
    if (datas) {
      this.datas = datas;
    }
    if (!this.datas) {
      throw new Error(
        " \u2718  Cradova err:  RefList cannot be rendered without input"
      );
    }
    if (!Array.isArray(this.datas)) {
      throw new Error(
        " \u2718  Cradova err:  RefList cannot render non-array input"
      );
    }
    const elements = [];
    const data = this.datas.length;
    for (let i = 0; i < data; i++) {
      elements.push(
        this.component(this.datas[i], i)({ stateID: this.stateID })
      );
    }
    return elements;
  }
  updateState(datas) {
    if (!datas) {
      throw new Error(" \u2718  Cradova err:  Ref cannot be rendered without input");
    }
    if (!Array.isArray(datas)) {
      throw new Error(
        " \u2718  Cradova err:  RefList cannot render non-array input"
      );
    }
    if (!datas[0]) {
      return;
    }
    if (!this.parentElement) {
      this.parentElement = dispatch(this.stateID, {
        cradovaDispatchTrackBreak: true
      })?.parentElement;
    }
    if (!this.parentElement) {
      throw new Error(
        "\u2718  Cradova err :  cannot update list, the RefList was never rendered!"
      );
    }
    const elements = [];
    for (let i = 0; i < datas.length; i++) {
      elements.push(this.component(datas[i], i)({ stateID: this.stateID }));
    }
    try {
      this.parentElement.replaceChildren(...elements);
    } catch (err2) {
      console.error(err2);
      throw new Error(" \u2718  Cradova err:  an error occured");
    }
  }
  remove() {
    dispatch(this.stateID, { remove: true });
  }
  instance() {
    return dispatch(this.stateID, {
      cradovaDispatchTrackBreak: true
    });
  }
  i() {
    return dispatch(this.stateID, {
      cradovaDispatchTrackBreak: true
    });
  }
};
var Ref = class {
  constructor(component) {
    this.stateID = uuid();
    this.data = void 0;
    this.component = component.bind(this);
  }
  stale(data) {
    this.data = data;
  }
  r(d) {
    return this.render(d);
  }
  u(d) {
    return this.updateState(d);
  }
  render(data) {
    if (data) {
      this.data = data;
    }
    const chtml = this.component(this.data);
    if (typeof chtml !== "function") {
      throw new Error(
        " \u2718  Cradova err :  Invalid component type for cradova Ref, got  -  " + chtml
      );
    }
    const element = chtml({ stateID: this.stateID });
    if (!(element instanceof HTMLElement)) {
      err(
        [
          `
     \x1B[35m Exception: ref only  a function that returns cradova element or cradova element tree. \x1B[35m
      
      to track and debug this element add a
      beforeMount or afterMount prop to the element
      then you can compare the parsed element and stateID

     element stateID: \x1B[4m \x1B[33m ${this.stateID} \x1B[33m \x1B[4m`
        ],
        `Cradova can't render component make sure it's a valid component`
      );
    }
    return () => element;
  }
  instance() {
    return dispatch(this.stateID, {
      cradovaDispatchTrackBreak: true
    });
  }
  i() {
    return dispatch(this.stateID, {
      cradovaDispatchTrackBreak: true
    });
  }
  onStateUpdate(cb) {
    this.upcb = cb;
  }
  updateState(data) {
    if (!data) {
      return;
    }
    if (!this) {
      console.error(
        " \u2718  Cradova err:  update has been passed wrongly please send the ref where you want to call it"
      );
      console.error(
        " \u2718  Cradova err: Then call as ref.updateState({ your new data }) = ui state"
      );
    }
    const guy = dispatch(this.stateID, {
      cradovaDispatchTrackBreak: true
    });
    if (!guy) {
      console.error(this.component);
      throw new Error(
        " \u2718  Cradova err:  Ref is not rendered but updateState was called"
      );
    }
    const chtml = this.component(data);
    if (typeof chtml !== "function") {
      try {
        guy.parentNode.replaceChild(chtml, guy);
      } catch (e) {
        console.error(" \u2718  Cradova err:  ", e);
        throw new Error(
          " \u2718  Cradova err:   Ref got an invalid datatype for ref updateSate call  got >>>  ' " + chtml + "';"
        );
      }
    }
    const element = chtml({ stateID: this.stateID });
    const fn = element.afterMount;
    element.afterMount = void 0;
    try {
      guy.parentNode.replaceChild(element, guy);
      if (typeof fn === "function") {
        fn(element, data);
      }
    } catch (e0) {
      console.log(e0);
    }
    if (this.upcb) {
      this.upcb(data);
    }
  }
  remove() {
    dispatch(this.stateID, { remove: true });
  }
};
var frag = function(...children) {
  const par = document.createDocumentFragment();
  for (let i = 0; i < children.length; i++) {
    const ch = children[i]();
    if (typeof ch === "function") {
      par.append(ch());
    } else {
      if (ch instanceof HTMLElement) {
        par.append(ch);
      }
    }
  }
  return par;
};

// lib/scripts/track.ts
function cradovaDispatchTrack(nodes, state) {
  for (let i = 0; i < nodes.length; i++) {
    const element = nodes[i];
    if (!element) {
      continue;
    }
    if (typeof state === "object") {
      for (const key in state) {
        if (key === "style") {
          for (const [k, v] of Object.entries(state[key])) {
            if (typeof element.style[k] !== "undefined" && k !== "src") {
              element.style[k] = v;
            } else {
              throw new Error(
                "\u2718  Cradova err : " + k + " is not a valid css style property"
              );
            }
          }
          continue;
        }
        if (typeof element.style[key] !== "undefined" && key !== "src") {
          element.style[key] = state[key];
          continue;
        }
        if (typeof element[key] === "function") {
          element[key](element);
          continue;
        }
        if (key === "text") {
          element.innerText = state[key];
          continue;
        }
        if (key === "fullscreen") {
          if (state[key]) {
            fullScreen(element).set();
          } else {
            fullScreen(element).exist();
          }
          continue;
        }
        if (key === "class" && typeof state[key] === "string") {
          const classes = state[key].split(" ");
          for (let i2 = 0; i2 < classes.length; i2++) {
            if (classes[i2]) {
              element.classList.add(classes[i2]);
            }
          }
          continue;
        }
        if (key === "toggleclass") {
          element.classList.toggle(state[key]);
          continue;
        }
        if (key === "removeclass") {
          element.classList.remove(state[key]);
          continue;
        }
        if (key === "remove") {
          element.parentElement?.removeChild(element);
          continue;
        }
        if (key === "tree") {
          if (typeof state[key] === "function") {
            state[key] = state[key]();
          }
          if (typeof state[key] === "function") {
            state[key] = state[key]();
          }
          if (Array.isArray(state[key])) {
            throw new TypeError(
              " \u2718  Cradova err:   invalid tree element type, should be a single element or parent element from cradova"
            );
          }
          if (!(state[key] instanceof HTMLElement)) {
            console.error(
              " \u2718  Cradova err:   wrong element type: can't update element state on " + state[key]
            );
            throw new TypeError(
              " \u2718  Cradova err:   invalid element, should be a html element from cradova"
            );
          }
          element.replaceChildren();
          element.append(state[key]);
          continue;
        }
        element[key] = state[key];
      }
    }
  }
}
function dispatch(stateID, state) {
  let updated = void 0;
  if (typeof state === "undefined" && typeof stateID === "object") {
    for (const [id, eachState] of Object.entries(stateID)) {
      const elements = document.querySelectorAll(
        "[data-cra-id=" + id + "]"
      );
      cradovaDispatchTrack(elements, eachState);
    }
  } else {
    if (typeof stateID === "string") {
      const elements = document.querySelectorAll(
        "[data-cra-id=" + stateID + "]"
      );
      if (elements.length) {
        if (state?.cradovaDispatchTrackBreak) {
          updated = elements[0];
        } else {
          cradovaDispatchTrack(elements, state);
        }
      }
    }
  }
  return updated;
}

// lib/scripts/createSignal.ts
var Signal = class {
  constructor(initial, props) {
    this.persistName = "";
    this.actions = {};
    this.useHistory = false;
    this.history = [];
    this.index = 0;
    this.path = null;
    this.value = null;
    this.value = initial;
    if (props && props.persistName) {
      this.persistName = props.persistName;
      const name = localStorage.getItem(props.persistName);
      if (name && name !== "undefined") {
        this.value = JSON.parse(name);
      }
    }
    if (props && props.useHistory) {
      this.useHistory = props.useHistory;
      this.history.push(initial);
    }
  }
  set(value, shouldRefRender) {
    if (typeof value === "function") {
      this.value = value(this.value);
    } else {
      this.value = value;
    }
    if (this.persistName) {
      localStorage.setItem(this.persistName, JSON.stringify(this.value));
    }
    if (this.ref && shouldRefRender !== false) {
      if (this.path) {
        this.ref.updateState(this.value[this.path]);
      } else {
        this.ref.updateState(this.value);
      }
    }
    if (this.callback) {
      this.callback(this.value);
    }
    if (!this.useHistory)
      return;
    this.index += 1;
    this.history.push(value);
  }
  setKey(name, value, shouldRefRender) {
    if (typeof this.value === "object" && !Array.isArray(this.value)) {
      this.value[name] = value;
      if (this.persistName) {
        localStorage.setItem(this.persistName, JSON.stringify(this.value));
      }
      if (this.ref && shouldRefRender !== false) {
        if (this.path) {
          this.ref.updateState(this.value[this.path]);
        } else {
          this.ref.updateState(this.value);
        }
      }
      if (this.callback) {
        this.callback(this.value);
      }
      if (!this.useHistory)
        return;
      this.history.push(this.value);
      this.index += 1;
    }
  }
  setPath(key, name, value, shouldRefRender) {
    if (this.value[key]) {
      this.value[key][name] = value;
    } else {
      this.value[key] = { [name]: [value] };
    }
    if (this.ref && shouldRefRender !== false) {
      if (this.path) {
        this.ref.updateState(this.value[this.path]);
      } else {
        this.ref.updateState(this.value);
      }
    }
  }
  setIndex(key, index, value, shouldRefRender) {
    if (Array.isArray(this.value[key])) {
      this.value[key][index] = value;
    } else {
      throw new Error(
        "\u2718  Cradova err :  " + this.value[key] + "  is not an array "
      );
    }
    if (this.ref && shouldRefRender !== false) {
      if (this.path) {
        this.ref.updateState(this.value[this.path]);
      } else {
        this.ref.updateState(this.value);
      }
    }
  }
  createAction(name, action) {
    if (typeof name === "string" && typeof action === "function") {
      this.actions[name] = action;
    } else {
      if (typeof name === "object" && !action) {
        for (const [nam, action2] of Object.entries(name)) {
          if (typeof nam === "string" && typeof action2 === "function") {
            this.actions[nam] = action2;
          } else {
            throw new Error(`\u2718  Cradova err : can't create action ${nam}`);
          }
        }
      } else {
        throw new Error(`\u2718  Cradova err : can't create action ${name}`);
      }
    }
  }
  fireAction(name, data) {
    try {
      if (!(typeof name === "string" && this.actions[name])) {
        throw Error("");
      }
    } catch (_e) {
      throw Error("\u2718  Cradova err : action " + name + "  does not exist!");
    }
    this.actions[name](this, data);
  }
  bindRef(Ref2, path) {
    if (Ref2 && Ref2.updateState) {
      this.ref = Ref2;
      if (typeof path === "string") {
        this.path = path;
        Ref2.stale(this.value[path]);
      } else {
        Ref2.stale(this.value);
      }
    } else {
      throw new Error("\u2718  Cradova err :  Invalid ref component" + Ref2);
    }
  }
  forward() {
    if (this.history.length > this.index + 1) {
      if (!this.useHistory)
        return;
      this.value = this.history[this.index + 1];
      this.index += 1;
    }
  }
  backward() {
    if (this.history.length > 0 && this.index > 0) {
      if (!this.useHistory)
        return;
      this.set(this.history[this.index + 1]);
      this.index -= 1;
    }
  }
  listen(callback) {
    this.callback = callback;
  }
  clearPersist() {
    if (this.persistName) {
      localStorage.setItem(this.persistName, JSON.stringify(""));
    }
  }
};

// lib/scripts/simplestore.ts
var simpleStore = class {
  constructor(initial, ref) {
    this.value = null;
    this.value = initial;
    this.bindRef(ref);
  }
  set(value, shouldRefRender) {
    if (typeof value === "function") {
      this.value = value(this.value);
    } else {
      this.value = value;
    }
    if (this.ref && shouldRefRender !== false) {
      this.ref.updateState(this.value);
    }
  }
  setKey(name, value, shouldRefRender) {
    if (typeof this.value === "object" && !Array.isArray(this.value)) {
      if (typeof value === "function") {
        this.value[name] = value(this.value);
      } else {
        this.value[name] = value;
      }
      if (this.ref && shouldRefRender !== false) {
        this.ref.updateState(this.value);
      }
    }
  }
  bindRef(Ref2) {
    if (Ref2 && Ref2.updateState) {
      this.ref = Ref2;
      if (Ref2.stale) {
        Ref2.stale(this.value);
      }
    } else {
      throw new Error("\u2718  Cradova err :  Invalid ref component" + Ref2);
    }
  }
};

// lib/scripts/ajax.ts
function Ajax(url, opts = {}) {
  const { method, data, header, callbacks } = opts;
  if (typeof url !== "string") {
    throw new Error("\u2718  Cradova err : little Axios invalid url " + url);
  }
  return new Promise(function(resolve) {
    const ajax = new XMLHttpRequest();
    const formData = new FormData();
    if (callbacks && typeof callbacks === "object") {
      for (const [k, v] of Object.entries(callbacks)) {
        if (typeof v === "function" && ajax[k]) {
          ajax[k] = v;
        }
      }
    }
    ajax.addEventListener("load", function() {
      resolve(ajax.response);
    });
    if (data && typeof data === "object") {
      for (const [k, v] of Object.entries(data)) {
        let value = v;
        if (typeof value === "object" && value && !value.name) {
          value = JSON.stringify(value);
        }
        formData.set(k, value);
      }
    }
    ajax.addEventListener("error", (e) => {
      console.error("\u2718  Cradova Ajax err : ", e);
      if (!navigator.onLine) {
        resolve(
          JSON.stringify({
            message: `the device is offline!`
          })
        );
      } else {
        resolve(
          JSON.stringify({
            message: `problem with the action, please try again!`
          })
        );
      }
    });
    if (!method) {
      ajax.open(data && typeof data === "object" ? "POST" : "GET", url, true);
    } else {
      ajax.open(method, url, true);
    }
    if (header && typeof header === "object") {
      Object.keys(header).forEach(function(key) {
        ajax.setRequestHeader(key, header[key]);
      });
    }
    ajax.send(formData);
  });
}

// lib/sacho/swipe1.ts
function swipe(callback, touching = false, element) {
  if (!(typeof callback === "function")) {
    throw new Error(
      " \u2718  Cradova err:  no function given for the swipe handler"
    );
  }
  let touchingState = false;
  let touchstartX = 0;
  let touchstartY = 0;
  let touchendX = 0;
  let touchendY = 0;
  function handleTouchStart(event) {
    touchstartX = Math.round(event.changedTouches[0].clientX);
    touchstartY = Math.round(event.changedTouches[0].clientY);
  }
  const capturedGesture = {
    top: 0,
    tap: 0,
    down: 0,
    left: 0,
    right: 0,
    touch: 0
  };
  function handleGesture(event) {
    touchendX = Math.round(
      event.changedTouches[event.changedTouches.length - 1].clientX
    );
    touchendY = Math.round(
      event.changedTouches[event.changedTouches.length - 1].clientY
    );
    if (touching) {
      capturedGesture.top = capturedGesture.down = capturedGesture.right = capturedGesture.left = capturedGesture.tap = capturedGesture.touch = 0;
    }
    if (touching) {
      if (touchingState) {
        handleTouchStart(event);
        touchingState = false;
      } else {
        capturedGesture.top = capturedGesture.down = capturedGesture.right = capturedGesture.left = capturedGesture.tap = capturedGesture.touch = 0;
        touchingState = true;
      }
    }
    if (touchendX > touchstartX) {
      capturedGesture.right = touchendX - touchstartX;
    }
    if (touchendX < touchstartX) {
      capturedGesture.left = touchstartX - touchendX;
    }
    if (touchendY > touchstartY) {
      capturedGesture.down = touchendY - touchstartY;
    }
    if (touchendY < touchstartY) {
      capturedGesture.top = touchstartY - touchendY;
    }
    if (touchendY == touchstartY) {
      capturedGesture.tap = touching ? 0 : 1;
      capturedGesture.touch = touching ? 1 : 0;
    }
    const keys = Object.keys(capturedGesture);
    let max = keys[0];
    for (let i = 1; i < keys.length; i++) {
      const value = keys[i];
      if (capturedGesture[value] > capturedGesture[max])
        max = value;
    }
    if (callback) {
      callback({ [max]: capturedGesture[max] });
    }
  }
  const escapeTSError = element || document.body;
  return {
    start() {
      if (touching) {
        escapeTSError?.addEventListener("touchmove", handleGesture);
      } else {
        escapeTSError?.addEventListener("touchstart", handleTouchStart);
        escapeTSError?.addEventListener("touchend", handleGesture);
      }
    },
    stop() {
      if (touching) {
        escapeTSError?.removeEventListener("touchmove", handleGesture);
      } else {
        escapeTSError?.removeEventListener("touchstart", handleTouchStart);
        escapeTSError?.removeEventListener("touchend", handleGesture);
      }
    }
  };
}

// lib/sacho/loadCss.ts
function loadCradovaUICss(seconds = 0.3) {
  const css2 = `:root {
--animation-timing: ${seconds + ""}s;
}

/* cradova roots*/

/*screen animations*/
.CRADOVA-UI-CIRCLE-OUT {
  animation: circle-out var(--animation-timing) ease forwards; 
}

.CRADOVA-UI-CIRCLE-IN {
  animation: circle-in var(--animation-timing) ease forwards; 
}

.CRADOVA-UI-SCALE-IN {
  animation: scale-in var(--animation-timing) ease forwards;
}

.CRADOVA-UI-SCALE-OUT {
  animation: scale-out var(--animation-timing) ease forwards;
}

.CRADOVA-UI-SLIDE-RIGHT {
  animation: slide-right var(--animation-timing) ease forwards;
}

.CRADOVA-UI-SLIDE-LEFT {
  animation: slide-left var(--animation-timing) ease forwards;
}

.CRADOVA-UI-SLIDE-UP {
  animation: slide-up var(--animation-timing) ease forwards;
}

.CRADOVA-UI-SLIDE-DOWN {
  animation: slide-down var(--animation-timing) ease forwards;
}

/* not done yet */ 

.CRADOVA-UI-FADE-IN {
  animation: fade-in var(--animation-timing) ease forwards;
}

.CRADOVA-UI-FADE-OUT {
  animation: fade-out var(--animation-timing) ease forwards;
}

/* ultility classes */

.CIRCLE-OUT {
  animation: fadeoff var(--animation-timing) ease forwards;
}

.CIRCLE-IN {
  animation: fadein var(--animation-timing) ease forwards;
}

/* animations  */

@keyframes circle-out {
  from {
    border-radius: 49%;
    /* width: 100%; */
    /* height: 100%; */
    margin: auto;
    margin-top: 40%;
  }
  
  to  {
    border-radius: 100%;
    /* width: 0%; */
    /* height: 0%; */
    margin: auto;
    margin-top: 50%;
  }
}

@keyframes circle-in {
  from {
    border-radius: 100%;
    /* width: 0%; */
    /* height: 0%; */
    margin: auto;
    margin-top: 40%;
  }
  to  {
    border-radius: 0%;
    /* width: 100vw; */
    /* height: 100vh; */
    margin: auto;
    margin-top: 0%;
  }
}

@keyframes scale-in {
  from {
   transform: scale(1);
  } 
  to {
   transform: scale(0);
  }
}


@keyframes scale-out {
  from {
    transform: scale(0);
    } 
  to {
    transform: scale(1);
   }
}

@keyframes slide-right {
  from {
  margin-left: -140%;
  }
  to  {
  margin-left: 0%;
  }
}

@keyframes slide-left {
  from {
  margin-left: 140%;
  }
  to  {
  margin-left: 0%;
  }
}

@keyframes slide-up {
  from {
  margin-top: 140%;
  }
  to  {
  margin-top: 0%;
  }
}

@keyframes slide-down {
  from {
  margin-top: -140%;
  }
  to  {
  margin-top: 0%;
  }
}

@keyframes fade-in {
  from {
  opacity: 0;
  }
  to  {
  opacity: 1;
  }
}

@keyframes fade-out {
  from {
  opacity: 1;
  }
  to  {
  opacity: 0;
  }
}

/* ultility animations */


@keyframes fadeoff {
  50%{
    opacity: 0;
  }
  100% {
    opacity: 0;
  }
} 

@keyframes fadein {
  0% { 
    opacity: 0;
}
  70%{
    opacity: 1;
  }
  100% {
    opacity: 1;
  }
} `;
  const style = document.createElement("style");
  style.innerHTML = css2;
  document.head.appendChild(style);
}

// lib/scripts/utils.ts
function IsElementInView(element) {
  const rect = element.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || window.document.documentElement.clientHeight) && rect.right <= (window.innerWidth || window.document.documentElement.clientWidth);
}

// lib/scripts/init.ts
var Init = function() {
  if (document.querySelector("[data-cra-id=cradova-app-wrapper]")) {
    return;
  }
  const Wrapper = document.createElement("div");
  Wrapper.setAttribute("data-cra-id", "cradova-app-wrapper");
  document.body.append(Wrapper);
};

// lib/index.ts
var make = function(txx) {
  if (!txx) {
    return {
      tag: "div"
    };
  }
  let tag;
  let innerValue = "";
  if (txx.includes("|")) {
    const tc = txx.split("|");
    innerValue = tc[1];
    txx = tc[0] && tc[0];
  }
  const itemsPurifier = () => {
    if (!txx.includes("#")) {
      txx = txx.split(".");
      tag = txx[0];
      if (tag) {
        txx.shift();
      } else {
        tag = "div";
      }
      return [txx, []];
    } else {
      if (!txx.includes(".")) {
        txx = txx.split("#");
        tag = txx[0];
        if (tag) {
          txx.shift();
        } else {
          tag = "div";
        }
        if (txx[0].includes(" ")) {
          txx = [txx[0].split(" ")[1]];
        }
        return [[], txx];
      }
    }
    txx = txx.split(".");
    const pureItems = [];
    const impureItems = [];
    tag = !txx[0].includes("#") && txx[0];
    if (tag) {
      txx.shift();
    }
    for (let i = 0; i < txx.length; i++) {
      if (txx[i].includes("#")) {
        const item = txx[i].split("#");
        impureItems.push(item[1]);
        if (i === 0) {
          tag = item[0];
          continue;
        }
        pureItems.push(item[0]);
        continue;
      }
      pureItems.push(txx[i]);
    }
    if (!tag) {
      tag = "div";
    }
    return [pureItems, impureItems];
  };
  const [classes, ids] = itemsPurifier();
  const ID = ids && ids[0];
  const className = classes && classes.join(" ");
  return { tag, className, ID, innerValue };
};
var _ = (...element_initials) => {
  let firstProps, firstLevelChildren = [], beforeMount;
  if (Object.prototype.toString.call(element_initials[1]) === "[object Object]") {
    firstProps = element_initials[1];
    if (firstProps?.beforeMount) {
      beforeMount = firstProps["beforeMount"];
      firstProps["beforeMount"] = void 0;
    }
    if (element_initials.length > 2) {
      firstLevelChildren = element_initials.slice(2, element_initials.length);
    }
  } else {
    if (element_initials[1] instanceof HTMLElement || typeof element_initials[1] === "function" || typeof element_initials[1] === "string") {
      firstLevelChildren = element_initials.slice(1, element_initials.length);
    }
  }
  if (element_initials[0].raw) {
    element_initials[0] = element_initials[0]["raw"][0];
  }
  function identify(element_initials2) {
    if (typeof element_initials2 !== "object") {
      element_initials2 = [element_initials2];
    }
    const initials = make(element_initials2[0]);
    return (...incoming) => {
      let secondLevelChildren = [], props = {}, text;
      for (let i = 0; i < incoming.length; i++) {
        if (Object.prototype.toString.call(incoming[i]) === "[object Object]") {
          props = incoming[i];
          if (incoming[i].beforeMount) {
            beforeMount = incoming[i]["beforeMount"];
            incoming[i]["beforeMount"] = void 0;
          }
          continue;
        }
        if (typeof incoming[i] === "function" || incoming[i] instanceof HTMLElement) {
          secondLevelChildren.push(incoming[i]);
          continue;
        }
        if (typeof incoming[i] === "string") {
          text = incoming[i];
          continue;
        }
      }
      if (firstLevelChildren.length) {
        secondLevelChildren.push(...firstLevelChildren);
      }
      let element;
      try {
        element = document.createElement(initials.tag.trim());
      } catch (error) {
        throw new TypeError(
          " \u2718  Cradova err:  invalid tag given  " + initials.tag
        );
      }
      if (initials.className) {
        element.className = initials.className.trim();
      }
      if (initials.ID) {
        element.setAttribute("id", initials.ID.trim());
      }
      if (initials.innerValue) {
        element.innerText = initials.innerValue;
      }
      if (firstProps) {
        for (const prp in firstProps) {
          props[prp] = firstProps[prp];
        }
      }
      for (const prop in props) {
        if (prop === "style" && typeof props[prop] === "object") {
          for (const [k, v] of Object.entries(props[prop])) {
            if (typeof element.style[k] !== "undefined" && k !== "src") {
              element.style[k] = v;
            } else {
              throw new Error(
                "\u2718  Cradova err :  " + k + " is not a valid css style property"
              );
            }
          }
          continue;
        }
        if (typeof element.style[prop] !== "undefined" && prop !== "src") {
          element.style[prop] = props[prop];
          continue;
        }
        if (prop === "text" && typeof props[prop] === "string") {
          text = props[prop];
          continue;
        }
        if (prop === "class" && typeof props[prop] === "string") {
          element.classList.add(props[prop]);
          continue;
        }
        if (prop === "beforeMount") {
          beforeMount = props["beforeMount"];
          props["beforeMount"] = void 0;
          continue;
        }
        if (prop === "stateID") {
          element.setAttribute("data-cra-id", props[prop]);
          continue;
        }
        if (prop.includes("$")) {
          element.setAttribute("data-" + prop.split("$")[1], props[prop]);
          continue;
        }
        try {
          element[prop] = props[prop];
        } catch (error) {
          console.error(" \u2718  Cradova err:  ", error);
        }
      }
      if (secondLevelChildren.length) {
        for (let i = 0; i < secondLevelChildren.length; i++) {
          if (typeof secondLevelChildren[i] === "function") {
            let child2 = secondLevelChildren[i]();
            if (typeof child2 === "function") {
              child2 = child2();
            }
            try {
              if (child2) {
                element.append(child2);
              }
              if (child2 && child2.afterMount) {
                child2.afterMount(child2);
                child2.afterMount = void 0;
              }
            } catch (error) {
              console.error(" \u2718  Cradova err:  ", error);
              if (!(child2 instanceof HTMLElement)) {
                throw new Error(
                  "  \u2718  Cradova err:  invalid child type: " + child2 + " (" + typeof child2 + ")"
                );
              }
            }
            continue;
          }
          if (Array.isArray(secondLevelChildren[i])) {
            const arrCX = secondLevelChildren[i];
            const arrCXLength = arrCX.length;
            const arrSET = [];
            for (let p = 0; p < arrCXLength; p++) {
              if (!(arrCX[p] instanceof HTMLElement) && typeof arrCX[p] !== "function" && !Array.isArray(arrCX[p])) {
                console.error(" \u2718  Cradova err:  ", arrCX[p]);
                throw new TypeError(
                  " \u2718  Cradova err: invalid tag type or template literal, cradova was enable to create this element show above \u21D1"
                );
              }
              arrSET.push(arrCX[p]);
            }
            secondLevelChildren = [
              ...secondLevelChildren.slice(0, i + 1),
              ...arrSET,
              ...secondLevelChildren.slice(i + 1, secondLevelChildren.length)
            ];
            continue;
          }
          const child = secondLevelChildren[i];
          if (child instanceof HTMLElement || child instanceof DocumentFragment) {
            element.append(child);
            if (child.afterMount) {
              child.afterMount(child);
              child.afterMount = void 0;
            }
          } else {
            if (typeof child === "string") {
              text = child;
            } else {
              console.error(" \u2718  Cradova err:   got", child);
              throw new Error(
                "  \u2718  Cradova err:  invalid child type: (" + typeof child + ")"
              );
            }
          }
        }
      }
      if (text) {
        element.innerText = text;
      }
      if (beforeMount) {
        beforeMount(element);
      }
      return element;
    };
  }
  if (typeof element_initials[0] !== "string") {
    console.error(" \u2718  Cradova err: NO TEMPLATE STRING PROVIDED");
    return () => " \u2718 NO TEMPLATE STRING PROVIDED";
  }
  return identify(element_initials);
};
Init();
var lib_default = _;
export {
  RefElement as $,
  Ajax,
  IsElementInView,
  PromptBeforeLeave,
  Ref,
  RefElement,
  RefList,
  Router,
  Scaffold,
  Screen,
  animate,
  assert,
  assertOr,
  controls,
  Signal as createSignal,
  css,
  lib_default as default,
  dispatch,
  frag,
  fullScreen,
  loadCradovaUICss,
  ls,
  make,
  media,
  simpleStore,
  swipe,
  uuid
};
